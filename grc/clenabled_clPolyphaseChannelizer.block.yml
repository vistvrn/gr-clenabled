# auto-generated by grc.converter

id: clenabled_clPolyphaseChannelizer
label: OpenCL Polyphase Channelizer
category: '[OpenCL-Accelerated]'

parameters:
-   id: openCLPlatform
    label: OpenCL Platform Type
    dtype: enum
    options: ['1', '2', '3', '4']
    option_labels: [GPU, Accelerator, CPU, Any]
-   id: devices
    label: OpenCL Device
    dtype: enum
    options: ['1', '2']
    option_labels: [Any, Specific]
    option_attributes:
        hide_specific: [all, '']
-   id: platformId
    label: Platform Id
    dtype: enum
    options: ['0', '1', '2', '3']
    hide: ${ devices.hide_specific }
-   id: deviceId
    label: Device Id
    dtype: enum
    options: ['0', '1', '2', '3']
    hide: ${ devices.hide_specific }
-   id: taps
    label: Taps
    dtype: real_vector
-   id: buf_items
    label: Buffer Items
    dtype: int
-   id: num_channels
    label: Number of Channels
    dtype: int
-   id: ninputs_per_iter
    label: Num Inputs per Iteration
    dtype: int
-   id: chmap
    label: Channel Map
    dtype: int_vector
-   id: setDebug
    label: Debug
    dtype: enum
    options: ['0', '1']
    option_labels: ['Off', 'On']

inputs:
-   domain: stream
    dtype: complex

outputs:
-   domain: stream
    dtype: complex

templates:
    imports: import clenabled
    make: |-
        % if devices == 1:
        clenabled.clPolyphaseChannelizer(${openCLPlatform}, 1, 0, 0, ${taps}, ${buf_items}, ${num_channels}, ${ninputs_per_iter}, ${chmap})
        % else:
        clenabled.clPolyphaseChannelizer(${openCLPlatform}, ${devices}, ${platformId}, ${deviceId}, ${taps}, ${buf_items}, ${num_channels}, ${ninputs_per_iter}, ${chmap})
        % endif

documentation: |-
    This block implements a polyphase channelizer using OpenCL.  It is similar to the core Polyphase Channelizer block, but outputs to a single multiplexed stream instead of individual streams.  Following this block with a Stream to Streams block provides multiple outputs similarly to the core block.

    The Number of Channels parameter is the number of channels that the input signal will be divided into.  This value does not include the effect of the channel map, which can change the number of output channels multiplexed into the output stream.  The Number of Channels is restricted to the transform sizes supported by clFFT (powers of 2, 3, 5, 7, 11 and 13).

    The Taps decribe the characteristics of the filter applied to each channel.  The filter taps should be calculated for the input sample rate.

    The Buffer Items parameter controls the number of items worked on by the block at one time, and must be a multiple of the Number of Channels parameter.  Increasing Buffer Items allows for greater throughput at the cost of higher latency.  A reasonable starting value for this parameter is approximately the input sample rate / 50.  For larger sample rates, the Min Output Buffer of the preceding block may need to be specified to be at least as large as the number of Buffer Items for the channelizer.

    The Num Inputs per Iteration is how many input samples are consumed when producing one sample for each of the (Number of Channels).  The sample rate of each output channel is (input sample rate) / (Num Inputs per Iteration).  When Num Inputs per Iteration = Number of Channels, no oversampling occurs and the output channels are non-overlapping.  When Num Inputs per Iteration &lt; Number of Channels, the output channels increase in sample rate and overlap each other.  In other words, the oversampling ratio is Number of Channels / Num Inputs per Iteration.

    The Channel Map selects the computed channels and the describes the sequence in which they are multiplexed in the output stream.  Channel 0 represents the center of the input signal, with increasing numbers increasing in frequency and wrapping around.  Only the selected channels are transferred from the GPU memory back to the host.

file_format: 1
